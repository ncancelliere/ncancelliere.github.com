<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title>Nicholas' Adventures</title>
  <link href="http://www.ozmox.com/atom.xml" rel="self"/>
  <link href="http://www.ozmox.com/"/>
  <updated>2011-08-04T23:02:10-05:00</updated>
  <id>http://www.ozmox.com/</id>
  <author>
    <name>Nicholas Cancelliere</name>
    
  </author>

  
  <entry>
    <title>Pardon the Dust</title>
    <link href="http://www.ozmox.com/blog/2011/08/04/pardon-the-dust/"/>
    <updated>2011-08-04T22:27:00-05:00</updated>
    <id>http://www.ozmox.com/blog/2011/08/04/pardon-the-dust</id>
    <content type="html">&lt;p&gt;With the economy being what it is, etc. I decided hosting with Joyent just wasn't really worth it. They're a great cloud provider, but for small time stuff -- like my blog -- it just didn't make sense. I started with them a while back but I think they've out-grown me.&lt;/p&gt;

&lt;p&gt;So I looked around for an alternative hosting provider. I like Heroku, but its read-only file system provides for some unique challenges. AWS (Amazon Web Services) are okay but can be expensive, although the first year is free. I'm already paying for a GitHub account and realized that I could just host a Jekyll website on my GitHub Pages.  So that's what I've done.&lt;/p&gt;

&lt;p&gt;I'm using Octopress, and I'm pretty happy. I was going to write my own blogging software but then realized I really don't have the time to do that. And why, since other smart people have done it! Expect more to come in the future. I've copied my most popular articles over. It's hard to beleive I've been writing this blog since 2008! So I've heavily culled the article set.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Installing Sun (Oracle) Java 6 JRE/JDK on Ubuntu 11</title>
    <link href="http://www.ozmox.com/blog/2011/04/30/installing-sun-oracle-java-6-jre-jdk-on-ubuntu-11/"/>
    <updated>2011-04-30T22:15:00-05:00</updated>
    <id>http://www.ozmox.com/blog/2011/04/30/installing-sun-oracle-java-6-jre-jdk-on-ubuntu-11</id>
    <content type="html">&lt;p&gt;In Ubuntu 11 it's really easy to install Sun's version of Java JDK (or JRE). Why would you want to do this?  Well, personally, I have found that the OpenJDK doesn't always work quite exactly right with a lot of Java programs, so I prefer to use the Sun JDK (I guess it's Oracle now).&lt;/p&gt;

&lt;p&gt;To install simply do the following from your console:&lt;/p&gt;

&lt;pre&gt;
sudo add-apt-repository ppa:ferramroberto/java
sudo apt-get update
sudo apt-get install sun-java6-jdk sun-java6-jre
sudo update-alternatives --config java
&lt;/pre&gt;


&lt;p&gt;Then you'll want to pick the Sun version of Java.  Now you'll be using Sun Java whenever you execute the 'java' command.  You can also verify this by typing 'java --version' and you should see the HotSpot mentioned, instead of the IcedTea.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Blurry Fonts on External Monitor With MacBook Pro</title>
    <link href="http://www.ozmox.com/blog/2010/08/29/blurry-fonts-on-external-monitor-with-macbook-pro/"/>
    <updated>2010-08-29T22:21:00-05:00</updated>
    <id>http://www.ozmox.com/blog/2010/08/29/blurry-fonts-on-external-monitor-with-macbook-pro</id>
    <content type="html">&lt;p&gt;I don't know if you have the same problem as me, but when I plug my MacBook Pro into my HP w2338h monitor the fonts are not as crisp as on the laptop itself.  I found out that there's a bug in how Mac OS X detects whether it should use font smoothing or not for certain external monitors. It's not a problem if you're using an Apple monitor (obviously their stuff works perfectly with their own stuff), but not all of us as so fortunate to shell out that kind of cash.&lt;/p&gt;

&lt;p&gt;You can easily fix this by typing the following into your command line:&lt;/p&gt;

&lt;pre&gt;
defaults -currentHost write -globalDomain AppleFontSmoothing -int 2
&lt;/pre&gt;


&lt;p&gt;You can try int 1 to 3 (to play with various levels of font smoothing, I found 2 to work best for me).  To remove the setting just open the Appearance app (inside the Control Panel) and at the bottom you'll see LCD font smoothing with a [-] inside, click it off and back on and it'll show up as an [x] (and you'll be back to where you started).&lt;/p&gt;

&lt;p&gt;You may have to quit and restart your application before you see the effect.  I tested it out using my terminal application since that's something I use quite a lot and not having nice smooth fonts in it makes me cry.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Nokogiri - Cut With Precision</title>
    <link href="http://www.ozmox.com/blog/2009/11/15/nokogiri---cut-with-precision/"/>
    <updated>2009-11-15T22:25:00-06:00</updated>
    <id>http://www.ozmox.com/blog/2009/11/15/nokogiri---cut-with-precision</id>
    <content type="html">&lt;p&gt;Many times we as developers have to deal with complex data, be it an ActiveResource result set or a HTML/XML document.  Trying to parse data out of these using for each and nesting loops within loops can be cumbersome.  A more elegant solution is to use nokogiri and xpath.&lt;/p&gt;

&lt;p&gt;Nokogiri is a type of Japanese saw, it also is a gem in Ruby that you can use to easily deal with XML or HTML documents.  (hint, ActiveRecord and ActiveResource objects both have to_xml methods).  You can easily install nokogiri (make sure you have libxml2 development packages installed, as the gem requires these to be properly built).&lt;/p&gt;

&lt;p&gt;$ sudo gem install nokogiri&lt;/p&gt;

&lt;p&gt;Now consider the following XML document: &lt;a title=&quot;foods.xml&quot; href=&quot;http://gist.github.com/235268&quot; target=&quot;_blank&quot;&gt;foods.xml&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Before we can work with our data we need to read XML into Nokogiri.  This is easy to accomplish:&lt;/p&gt;

&lt;pre&gt;&amp;gt; require 'rubygems'
&amp;gt; require 'nokogiri'
&amp;gt; doc = Nokogiri::XML.parse(File.read('foods.xml'))
=&amp;gt; #&amp;lt;Nokogiri::XML::Document:0x3f930c9db884 ...&lt;/pre&gt;


&lt;p&gt;What we are returned is a Nokogiri document which is a collection of Nokogiri elements and text objects.  The document supports seaching (selecting a subset of nodes, or nokogiri nodeset) by both CSS selectors or XPath notation.  These are returned as an array of elements and text objects.&lt;/p&gt;

&lt;p&gt;So for example if we wanted to know all the names of the food items in our document we simply say:&lt;/p&gt;

&lt;pre&gt;&amp;gt; doc.xpath(&quot;//name&quot;).collect(&amp;amp;:text)
=&amp;gt; [&quot;carrot&quot;, &quot;tomato&quot;, &quot;corn&quot;, &quot;grapes&quot;, &quot;orange&quot;, &quot;pear&quot;, &quot;apple&quot;]&lt;/pre&gt;


&lt;p&gt;If we were interested in the entire node we could leave off the .collect(&amp;amp;:text). What if we wanted to select all the names of food items that were best baked?  This requires us to use what's called an axis - we will first need to find the element &quot;baked&quot; but then go back up our XML elements to find which food the item is inside.&lt;/p&gt;

&lt;pre&gt;&amp;gt; doc.xpath(&quot;//tag[text()='baked']/ancestor::node()/name&quot;).collect(&amp;amp;:text)
=&amp;gt; [&quot;pear&quot;, &quot;apple&quot;]&lt;/pre&gt;


&lt;p&gt;What if we were only interested in vegetables that were good for roasting?  Just add //veggies:&lt;/p&gt;

&lt;pre&gt;&amp;gt; doc.xpath(&quot;//veggies//tag[text()='roasted']/ancestor::node()/name&quot;).collect(&amp;amp;:text)
=&amp;gt; [&quot;carrot&quot;, &quot;tomato&quot;]&lt;/pre&gt;


&lt;p&gt;What about if we wanted to know all the tags 'corn' had?  Again this is very easy:&lt;/p&gt;

&lt;pre&gt;&amp;gt; doc.xpath(&quot;//name[text()='corn']/../tags/tag&quot;).collect(&amp;amp;:text)
=&amp;gt; [&quot;raw&quot;, &quot;boiled&quot;, &quot;grilled&quot;]&lt;/pre&gt;


&lt;p&gt;We can even do searches matching the first character.  Let's say we wanted to know all the food items that started with the letter 'c':&lt;/p&gt;

&lt;pre&gt;&amp;gt; doc.xpath(&quot;//name[starts-with(text(),'c')]&quot;).collect(&amp;amp;:text)
=&amp;gt; [&quot;carrot&quot;, &quot;corn&quot;]&lt;/pre&gt;


&lt;p&gt;You have to admit this is pretty cool stuff.  You could also use &lt;strong&gt;[contains(text(),'rot']&lt;em&gt; &lt;/em&gt;&lt;/strong&gt;and get back just carrot, useful when you want to do a partial match.  Axis combined with selectors give you a wide variety of options for parsing your dataset.  You can also match using operations.  See the links below for resources on the variety of options available.&lt;/p&gt;

&lt;h3&gt;Xpath is Powerful&lt;/h3&gt;


&lt;p&gt;Xpath lets us select XML elements, attributes and text without having to write cumbersome recursive, nested loops. Below are  links to online resources and tutorials.  The next time you have to dig through an XML document or ActiveResource result, don't use recursive, nested loops; instead, consider a Japanese saw - nokogiri.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Learn More&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.zvon.org/xxl/XPathTutorial/General/examples.html&quot;&gt;A good XPath tutorial using examples (by Miloslav Nic)&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.w3schools.com/XPath/xpath_syntax.asp&quot;&gt;W3Schools Xpath Syntax tutorial&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://nokogiri.rubyforge.org/nokogiri/&quot;&gt;Nokogiri Docs&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://techiferous.com/2009/12/getting-started-with-nokogiri/&quot; target=&quot;_blank&quot;&gt;Getting Started with Nokogiri&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;



</content>
  </entry>
  
</feed>
